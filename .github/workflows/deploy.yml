name: Deploy Node.js application to EC2

on:
  push:
    branches:
      - main # main 브랜치에 push 될 때마다 워크플로우 실행

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22' # EC2에 설치된 Node.js 버전과 일치시키세요 (v22.17.1 이므로 22로 설정해도 됩니다.)

    - name: Install backend dependencies
      run: npm install
      working-directory: ./backend # 백엔드 폴더에서 의존성 설치

    - name: Build backend application (if applicable)
      run: npm run build
      working-directory: ./backend # 백엔드 폴더에서 빌드 (빌드 과정이 있다면)

    - name: Deploy to EC2
      uses: appleboy/ssh-action@master
      with: # 이 'with'는 'uses'와 같은 레벨 (스페이스 6칸)
        host: 44.212.4.6 # 이 'host'는 'with' 아래 2칸 더 들여쓰기 (스페이스 8칸)
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        # env 블록의 들여쓰기를 'with', 'host', 'username', 'key'와 동일하게 맞춥니다.
        env: # <-- 이 'env'는 'host', 'username', 'key'와 같은 레벨입니다. (스페이스 8칸)
          # Firebase 설정
          FIREBASE_TYPE: ${{ secrets.FIREBASE_TYPE }} # 이 변수들은 'env' 아래 2칸 더 들여쓰기 (스페이스 10칸)
          FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
          FIREBASE_PRIVATE_KEY_ID: ${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
          FIREBASE_PRIVATE_KEY: ${{ secrets.FIREBASE_PRIVATE_KEY }}
          FIREBASE_CLIENT_EMAIL: ${{ secrets.FIREBASE_CLIENT_EMAIL }}
          FIREBASE_CLIENT_ID: ${{ secrets.FIREBASE_CLIENT_ID }}
          FIREBASE_AUTH_URI: ${{ secrets.FIREBASE_AUTH_URI }}
          FIREBASE_TOKEN_URI: ${{ secrets.FIREBASE_TOKEN_URI }}
          FIREBASE_AUTH_PROVIDER_X509_CERT_URL: ${{ secrets.FIREBASE_AUTH_PROVIDER_X509_CERT_URL }}
          FIREBASE_CLIENT_X509_CERT_URL: ${{ secrets.FIREBASE_CLIENT_X509_CERT_URL }}
          FIREBASE_UNIVERSE_DOMAIN: ${{ secrets.FIREBASE_UNIVERSE_DOMAIN }}

          # 서버 설정
          PORT: ${{ secrets.PORT }}
          NODE_ENV: ${{ secrets.NODE_ENV }}

          # 로깅 설정
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          LOG_FILE: ${{ secrets.LOG_FILE }}

          # CORS 설정
          CORS_ORIGIN: ${{ secrets.CORS_ORIGIN }}

          # Rate Limiting 설정
          RATE_LIMIT_WINDOW_MS: ${{ secrets.RATE_LIMIT_WINDOW_MS }}
          RATE_LIMIT_MAX_REQUESTS: ${{ secrets.RATE_LIMIT_MAX_REQUESTS }}

          # Google OAuth 설정
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}

          # JWT 및 OpenAI 설정
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

        script: | # <-- 이 'script'도 'with', 'host', 'env'와 같은 레벨입니다. (스페이스 8칸)
          # EC2 서버에서 실행될 명령어들
          cd /home/ubuntu/ # EC2에 배포할 프로젝트의 상위 디렉토리
          # 기존 프로젝트 디렉토리가 있다면 삭제 (선택 사항, 필요에 따라)
          # rm -rf back_schedule_planner 

          # GitHub에서 프로젝트 클론 (처음 배포 시) 또는 풀 (이후 배포 시)
          if [ ! -d "back_schedule_planner" ]; then
            git clone https://${{ secrets.GITHUB_TOKEN }}@github.com/seominji58/back_schedule_planner.git
          else
            cd back_schedule_planner
            git pull origin main
          fi

          # 프로젝트 디렉토리 (backend 폴더까지)로 이동
          cd /home/ubuntu/back_schedule_planner/backend

          # Node.js 의존성 설치 (EC2에서는 이미 설치되어 있을 수도 있지만, 안전하게 다시 실행)
          npm install

          # PM2를 사용하여 애플리케이션 재시작 또는 시작
          # --env production 옵션을 사용하여 GitHub Actions에서 전달받은 환경 변수를 로드합니다.
          pm2 list | grep "schedule-planner-backend"
          if [ $? -eq 0 ]; then
            pm2 restart schedule-planner-backend --update-env
          else
            pm2 start dist/server.js --name schedule-planner-backend --env production
          fi

          # PM2 프로세스 목록 저장 (재부팅 시 자동 실행을 위해)
          pm2 save
